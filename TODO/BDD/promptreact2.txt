Cr√©e un service React pour r√©cup√©rer les d√©partements √† partir d‚Äôune API, en suivant l‚Äôexemple de code ci-dessous.
Le service doit utiliser @tanstack/react-query pour la gestion des requ√™tes et axios pour les appels HTTP.
Assure-toi de respecter les bonnes pratiques suivantes :

D√©finir une cl√© de requ√™te constante (queryKey)

Typage strict avec TypeScript pour la r√©ponse de l‚ÄôAPI

Utiliser la variable d‚Äôenvironnement BASE_URL provenant de config/apiConfig

G√©rer correctement les erreurs et le typage du r√©sultat

Voici un exemple √† suivre :

import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { BASE_URL } from '@/config/api-config';

const DEPARTMENTS_KEY = ['departments'] as const;

interface DepartmentsResponse {
  status: string;
  data: string[];
}

export const useDepartments = () => {
  return useQuery<DepartmentsResponse, Error>({
    queryKey: DEPARTMENTS_KEY,
    queryFn: async () => {
      const response = await axios.get(`${BASE_URL}/api/User/departments`, {
        headers: {
          accept: '*/*',
        },
      });
      return response.data;
    },
  });
};


voici le code a modifier :
"use client";


import { useCallback } from "react";
import { apiGet } from "utils/apiUtils";
import { handleValidationError } from "utils/validation";


export const formatNotificationData = (notificationRecipient) => {
    if (!notificationRecipient) return null;

    return {
        notificationId: notificationRecipient.notificationId || "Non sp√©cifi√©",
        userId: notificationRecipient.userId || "Non sp√©cifi√©",
        status: notificationRecipient.status || "pending",
        sentAt: notificationRecipient.sentAt || null,
        readAt: notificationRecipient.readAt || null,
        createdAt: notificationRecipient.createdAt || null,
        updatedAt: notificationRecipient.updatedAt || null,
        notification: {
            title: notificationRecipient.notification?.title || "Non sp√©cifi√©",
            message: notificationRecipient.notification?.message || "Non sp√©cifi√©",
            type: notificationRecipient.notification?.type || "info"
        },
        user: {
            name: notificationRecipient.user?.name || "Non sp√©cifi√©",
            email: notificationRecipient.user?.email || "Non sp√©cifi√©"
        }
    };
};

// ---------------------------------------------------------------------

export const GetLastThreeUnreadNotifications = () => {
    // Le hook renvoie une fonction qui exige le 'userId' en param√®tre.
    return useCallback(async (userId) => {
        if (!userId) {
            throw new Error("User ID is required.");
        }

        try {
            const response = await apiGet(`/api/notifications/by-user/${userId}/last-three-unread`);
            
            const data = Array.isArray(response) ? response : [];
            
            // Simplification de la map
            const formattedData = data.map(formatNotificationData);
            
            return formattedData;
        } catch (error) {
            handleValidationError(error);
            throw error;
        }
    }, []); // D√©pendance 'userId' supprim√©e, tableau vide.
};

// ---------------------------------------------------------------------

export const GetUnreadNotificationCount = () => {
    return useCallback(async (userId) => {
        if (!userId) {
            throw new Error("User ID is required.");
        }

        try {
            const response = await apiGet(`/api/notifications/by-user/${userId}/unread-count`);
            
            return {
                unreadCount: response?.unreadCount ?? 0
            };
        } catch (error) {
            handleValidationError(error);
            throw error;
        }
    }, []); // Tableau de d√©pendances vide.
};

// ---------------------------------------------------------------------

export const GetNotificationsByUser = () => {
    return useCallback(async (userId) => {
        if (!userId) {
            throw new Error("User ID is required.");
        }

        try {
            const response = await apiGet(`/api/notifications/by-user/${userId}`);
            
            const data = Array.isArray(response) ? response : [];
            
            const formattedData = data.map(formatNotificationData);
            
            return formattedData;
        } catch (error) {
            handleValidationError(error);
            throw error;
        }
    }, []); // Tableau de d√©pendances vide.
};

// ---------------------------------------------------------------------

export const GetUnreadNotificationCountByMenu = () => {
    return useCallback(async (userId, relatedMenu = null) => {
        if (!userId) {
            throw new Error("User ID is required.");
        }

        try {
            const url = relatedMenu
                ? `/api/notifications/by-user/${userId}/unread-count-by-menu?relatedMenu=${encodeURIComponent(relatedMenu)}`
                : `/api/notifications/by-user/${userId}/unread-count-by-menu`;
            const response = await apiGet(url);
            
            return response && typeof response === 'object' ? response : {};
        } catch (error) {
            handleValidationError(error);
            throw error;
        }
    }, []); // Tableau de d√©pendances vide.
};

üéØ Objectif final :
Cr√©er un hook qui renvoie les donn√©es de cette API en respectant la structure et les conventions de React Query et Axios.


















Convertis cette page actuellement en JSX vers TypeScript (TSX).

Int√®gre le service situ√© dans /api/users/services √† la page convertie.

Assure-toi de :

Typiser correctement tous les props, states, et fonctions ;

Remplacer tous les types implicites par des types explicites ;

G√©rer proprement les erreurs de typage apr√®s conversion ;

Conserver le m√™me comportement et la m√™me logique que dans la version JSX ;

Importer et utiliser le service depuis /api/users/services







{
  "token": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJtaWFudHNhZml0aWEucmFrb3RvYXJpbWFuYW5hQHJhdmluYWxhLWFpcnBvcnRzLmFlcm8iLCJuYW1lIjoiTWlhbnRzYWZpdGlhIFJBS09UT0FSSU1BTkFOQSAoRFJIKSIsImp0aSI6IjU3MGU4OTBmLTAzY2YtNDAyNy05NjQzLWFiM2NhYTdjNmJhZSIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL25hbWVpZGVudGlmaWVyIjoiY2U3OTZlYjYtMGY3ZS00ZGJjLTljMWUtZGUwMGY1M2RlMTg2IiwidXNlcl90eXBlIjoiTm9uQ2FkcmUiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsiYWRtaW4iLCJyaCIsImNvbGxhYm9yYXRldXIiXSwiZXhwIjoxNzYwMjUzMzY4LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjUxODMiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ.Yyu4is7gszrZYoTK5eEqgtmXPwHKD-uAy6pcQlcF2kY",
    "refreshToken": "8PgpgzJegRCpdEWBZaY+Re3CxmpDoqx3zj+BJIRXcy8=",
    "expiresIn": 60
  },
  "user": {
    "userId": "ce796eb6-0f7e-4dbc-9c1e-de00f53de186",
    "matricule": "ST154",
    "email": "miantsafitia.rakotoarimanana@ravinala-airports.aero",
    "name": "Miantsafitia RAKOTOARIMANANA (DRH)",
    "department": "DRH",
    "userType": 0
  },
  "message": "Success",
  "type": "success"
}


Comment faire ca J'utilise une .NET comme backend et react ts en frontend et ce que je veux si le token est espirer l'utilisateur doit refaire une login mais pour que le token n'est pas expirer a chaque 1 heure par example on appel cet refresh token :
curl -X 'POST' \
  'http://localhost:5183/api/Auth/refresh' \
  -H 'accept: */*' \
  -H 'Content-Type: application/json' \
  -d '{
  "refreshToken": "8PgpgzJegRCpdEWBZaY+Re3CxmpDoqx3zj+BJIRXcy8="
}'

{
  "token": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJtaWFudHNhZml0aWEucmFrb3RvYXJpbWFuYW5hQHJhdmluYWxhLWFpcnBvcnRzLmFlcm8iLCJuYW1lIjoiTWlhbnRzYWZpdGlhIFJBS09UT0FSSU1BTkFOQSAoRFJIKSIsImp0aSI6IjMzZjc4ZjAzLTNiODQtNGVmZS1hMDgxLWIzZDE3OGQwNDFkMyIsImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3dzLzIwMDUvMDUvaWRlbnRpdHkvY2xhaW1zL25hbWVpZGVudGlmaWVyIjoiY2U3OTZlYjYtMGY3ZS00ZGJjLTljMWUtZGUwMGY1M2RlMTg2IiwidXNlcl90eXBlIjoiTm9uQ2FkcmUiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsiYWRtaW4iLCJyaCIsImNvbGxhYm9yYXRldXIiXSwiZXhwIjoxNzYwMjUzNDk5LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjUxODMiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ.j2Go5NieoyKzswLaoXEj3ozOLvpdUVDk-j4zexR4RQU",
    "refreshToken": "xSz4rGhu30laT3VcaXju7JAtd454Fv16KMXmOUR6+nY=",
    "expiresIn": 60
  },
  "message": "Token refreshed successfully",
  "type": "success"
}

a chaque fois qu'on appel une api mais comment faire dans react pour que si le token est expirer et 